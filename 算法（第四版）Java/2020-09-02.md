# 排序

## 2.1.6 希尔排序

希尔排序是基于插入排序的快速排序算法。对于大规模乱序数组插入的排序很慢，因为它只会交换相邻的元素，因此元素只能一点一点地从数组的一端移动到数组的另一端。例如，如果主键最小的元素正好在数组的尽头，要将它挪到正确的位置就需要的 N-1 次移动。希尔排序为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。

希尔排序的思想是使数组中任意间隔为 h 的元素都是有序的。这样数组被称为 h 有序数组。换句话说，一个 h 有序数组就是 h 个相互独立的有序数组编织在一起组成的一个数组。在排序时， 如果 h 很大，我们就能将元素移动到很远的地方，为实现更小的 h 有序创造方便。用这种方式，对应任意以 1 结尾的 h 序列，我们都能讲数组排序。

**实现希尔排序的一种方法是对于每个 h， 用插入排序将 h 个子数组独立地排序。但因为子数组是相互独立的，一个更简单的方法是在 h- 子数组中将每个元素交换到比它大的元素之前去（将比它大的元素向右移动一格）， 只需要在插入排序的代码中将移动元素的距离由 1 改为 h 即可，这样，希尔排序的实现就转化为了一个类似于插入排序但使用不同增量的过程。**

希尔排序更高效的原因是它权衡了子数组的规模和有序性。排序之初，各个子数组都很短，排序之后子数组都是部分有序的。这两种情况都很适合插入排序。子数组部分有序的程度取决于递增序列的选择。

```java
public class Shell
{
  public static void sort(Comparable[] a)
  {
    int N = a.length;
    int h = 1;
    while(h < N/3) h = 3*h + 1;

    while(h >= 1)
    {
      for(int i = h; i < N; i++)
      {
        for(int j = i; j >= h && less(a[j], a[j-h]); j -= h)
        exch(a, j, j-h);
      }
      h = h/3;
    }
  }
}
```

如果我们在插入排序中加入一个外循环来将 h 按照递增序列递减，我们就能得到这个简洁的希尔排序。递增 h 的初始值是数组长度乘以一个常数因子，最小为1。

如何选择递增序列呢？要回答这个问题并不简单，算法的性能不仅取决于 h， 还取决于 h 之间的数学性质，比如它们的公因子等。有很多论文都研究了各种不同的递增序列，但都无法证明某个序列是最好的。

和选择排序以及插入排序形成对比的是，希尔排序也可用于大型数组，它对任意排序（不一定是随机的）的数组表现也很好。数组越大，优势越大。它对于中等大小的数组时间也是可以接受的，代码量很小，而且不需要额外的内存空间，还有更搞笑的算法，但除了对于很大的 N，它们可能只比希尔排序快2倍（可能达不到），而且更复杂。如果你需要解决一个排序问题而又没有系统排序函数可用，可以先用希尔排序，然后再考虑是否值得将它替换为更加复杂的排序算法。

建议：
对于部分有序和小规模的数组应该选择插入排序。

## 主题阅读

### 排序实现

#### 插入排序

```java
  public static int[] insertionSort(int[] array){
    if(array.length == 0) return array;

    int current;
    for(int i = 0; i < array.length-1; i++){
      current = array[i+1];
      int preIndex = i;
      while(preIndex >= 0 && current < array[preIndex]){
        array[preIndex + 1] = array[preIndex];
        preIndex--;
      }
      array[preIndex + 1] = current;
    }
    return array;
  }

  insertionSort([3, 1, 7, 5, 2, 4, 9, 6])
```

```c
void InsertSort(int a[], int n){
  for(int i = 1; i < n; i++){

    // 若第 i 个元素大于 i-1 元素则直接插入，反之，需要找到适当的插入位置后再插入。

    if(a[i] < a[i-1]){

      int j = i - 1;

      int x = a[i];

      // 采用顺序查找方式找到插入的位置，在查找的同时，将数组中的元素进行后移操作，给插入元素腾出空间。

      while(j>-1 && x < a[j]){
        a[j+1] = a[j];
        j--;
      }
      a[j+1] = x;
  }
}

int main(){
  int a[8] = {3, 1, 7, 5, 2, 4, 9, 6};
  InsertSort(a, 8);
  return 0;
}
```
