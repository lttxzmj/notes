# 排序

## 2.1 初级排序算法

重新排列数组元素的算法，其中每个元素都有一个主键。

### 2.1.1 模版

```java
  public class Example
  {
    public static void sort(Comparable[] a)
    {
      //
    }

    private static boolean less(Comparable v, Comparable w)
    {
      return v.compareTo(w) < 0;
    }

    private static void show(Comparable[] a)
    {
      for(int i = 0; i < a.length; i++)
        StdOut.print(a[i] + " ");
      StdOut.println();
    }

    public static boolean isSorted(Comparable[] a)
    {
      // 测试数组元素是否有序
      for(int i = 1; i < a.length; i++)
        if(less(a[i], a[i-1])) return false
        return true
    }

    public static void main(String[] args)
    {
      String[] a = In.readString();
      sort(a);
      assert isSorted(a);
      show(a)
    }
  }
```

#### 2.1.1.1 验证

无论数组的初始状态是什么，谨慎起见，需要添加 `assert isSorted(a)` 确认排序后的数组元素都是有序的。


当我们直接将值存入数组中时，这条语句无法提供足够的保证（例如，把初始数组的元素全部置为相同的值也能通过这个测试。）**不懂**

#### 2.1.1.2 运行时间

还要评估算法的性能。

- 要计算各个排序算法在不同的随机输入下的基本操作的次数（包括比较和交换，或者是读写数组的次数）
- 我们用这些数据来估计算法的相对性能并介绍在实验中验证这些猜想所用的工具。

排序算法中，我们需要计算比较和交换的数量，对于不交换的的算法，我们会计算访问数组的次数。

#### 2.1.1.3 额外的内存使用

排序算法的额外内存开销和运行时间是同等重要的。排序算法可以分为两类：除了函数调用所需要的栈和固定数目的实例变量之外无需额外内存的原地排序算法，以及需要额外内存空间来存储另一份数组副本的其他排序算法。

#### 2.1.1.4 数据类型

### 2.1.2 选择排序

选择排序：不断地选择剩余元素中最小者

  1. 找到数组中最小的那个元素
  2. 将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么它就和自己交换）
  3. 剩下的元素中找到最小的元素，将它和数组的第二个元素交换位置
  4. 如此往复，直到将整个数组排序

```java
  public class Selection
  {
    public static void sort(Comparable[] a)
    {
      // 将a[]按升序排列
      int N = a.length;
      for(int i = 0; i < N; i++)
      {
        int min = i;
        for(int j = i+1; j < N; j++)
         if(less(a[j], a[min])) min = j;
        exch(a, i, min)
      }
    }
  }
```

如上所示，选择排序的内循环只是在比较当前元素与目前已知的最小元素（以及将当前索引加1和检查是否代码越界）。交换元素的代码写在循环外，每次交换都能排定一个元素，因此交换的总次数是 N。因此算法的时间效率取决于比较的次数。

选择排序有两个鲜明的特点：

 1. 运行时间和输入无关
   为了找出最小的元素而扫描一遍数组并不能为下一遍扫描提供什么信息。这种性质在某些情况下是缺点，因为使用选择排序的人可能会惊讶地发现，一个已经有序的数组或是关键全部相等的数组和一个元素随机排列的数组所用的排序事件竟然一样长。我们将会看到，其他算法会更善于利用输入的初始状态。**不懂**

 2. 数据移动是最少的。每次交换都会改变两个数组元素的值，因此选择排序用了 N 次交换，——交换次数和数组大小是线性关系。

### 2.1.3 插入排序

整理桥牌的时候，是将每一张牌插入到其他已经有序的牌中的适当位置。在计算机中，为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。这种算法叫插入排序。

与选择排序一样，当前索引左边的所有元素都是有序的，但它们的最终位置还不确定，为了给更小的元素腾出空间，它们可能会被移动，。但是当索引到达数组的右端时。数组排序就完成了。

和选择排序不同的是，插入排序所需的事件取决于输入元素的初始顺序，例如，对一个很大且其中的元素有序（接近有序）的数组进行排序将会比对随机顺序的数组或是逆序数组进行排序要快的多。

插入排序对于实际应用中常见的某些类型的非随机数组很有效。当你用插入排序对一个有序数组进行排序时会发生什么。插入排序能够立即发现每个元素都已经在合适的位置上，它的运行时间也是线性的（对于这种数组，选择排序的运行时间是平方级别的）

```java
public class Insertion
{
  public static void sort(Comparable[] a)
  {
    // 将a[]按升序排列
    int N = a.length;
    for(int i = 1; i < N; i++)
    {
      for(int j = i; j > 0 && less(a[j], a[j-1]); j--)
      exch(a, j, j-1)
    }
  }
}
```

我们考虑的更一般的情况是部分有序的数组，倒置指的是数组中的两个顺序颠倒的元素，如果数组中倒置的数量小于数组大小的某个倍数，那么我们说这个数组是部分有序的。下面是几种典型的部分有序的数组：

- 数组中每个元素距离它的最终位置都不远。
- 一个有序的大数组接一个小数组。
- 数组中只有几个元素的位置不正确。

插入排序对这样的数组很有效，而选择排序则不然。事实上，当倒置的数量很少时，插入排序很可能比本章中的其他任何算法都要快。

**大幅提高插入排序的速度，只需要在内循环中将较大的元素都向右移动而不是交换两个元素。**（这样访问数组的次数就能减半）。（练习）

**总的来说，插入排序对部分有序的数组十分搞笑，也很适合小规模数组**，这很重要，因为这些类型的数组在实际应用中经常出现，而且他们也是高级排序算法中的中间过程。

性质： 对于随机排序的无重复主键的数组，插入排序和选择排序的运行时间是平方级别的，两者之比应该是一个较小的常数。（插入排序的事件比选择排序的时间快。